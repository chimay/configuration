" vim: set filetype=vim :

	if motif[0] == "'" && motif[-1:] = "'"
		motif = motif[1:-2]
	endif

"  {{{ Remplacement
" ------------------------------------------------------------------------

fu! bibliotheque#remplacement()

	let l:motif = input('Motif ? ')
	let l:remplace = input('Remplacement ? ')

	let l:fichiers = input('Fichiers ? ')

	if l:fichiers == ''
		let l:fichiers = '**'
	endif

	let l:separateurs = ['/', ':', '-', '_', ',', ';', '?']

	let l:sep = ''

	for l:candide in l:separateurs
		if ! (l:motif =~ l:candide)
			let l:sep = l:candide
			break
		endif
	endfor

	if l:sep == ''
		echoe 'Impossible de trouver un séparateur pour la substitution'
		return 1
	endif

	let l:chaine  = 'argdo %s'
	let l:chaine .= l:sep
	let l:chaine .= l:motif
	let l:chaine .= l:sep
	let l:chaine .= l:remplace
	let l:chaine .= l:sep
	let l:chaine .= 'ge'

	arglocal

	exe 'ar' l:fichiers
	exe l:chaine

	argglobal

endfu

" {{{ Ancien

"fu bibliotheque#remplacement(motif, remplace, ...)

	"if len(a:000) >= 1
		"let l:fichiers = ''
		"for l:f in a:000
			"let l:fichiers .= ' ' . l:f
		"endfor
	"else
		"let l:fichiers = '**/*'
	"endif

	"let l:separateurs = ['/', '?', ':', ';', '-']

	"let l:sep = ''

	"for l:candide in l:separateurs
		"if ! (a:motif =~ l:candide)
			"let l:sep = l:candide
			"break
		"endif
	"endfor

	"if l:sep == ''
		"echoe 'Impossible de trouver un séparateur pour la substitution'
		"return 1
	"endif

	"let l:chaine  = 'argdo %s'
	"let l:chaine .= l:sep
	"let l:chaine .= a:motif
	"let l:chaine .= l:sep
	"let l:chaine .= a:remplace
	"let l:chaine .= l:sep
	"let l:chaine .= 'g'

	"let l:arguments = []
	"let l:i = 0
	"let l:N = argc()
	"while l:i < l:N
		"let l:arguments += [argv(l:i)]
		"let l:i = l:i + 1
	"endwhile

	"exe 'ar' l:fichiers
	"exe l:chaine
	"exe 'ar' join(l:arguments)

"endfu

" }}}

" }}}

" {{{ fu bibliotheque#vimGrep(...)

" fu bibliotheque#vimGrep(...)

	"if len(a:000) >= 1
		"let l:fichiers = ''
		"for l:f in a:000
			"let l:fichiers .= ' ' . l:f
		"endfor
	"else
		"let l:fichiers = '**/*'
	"endif

	"let l:motif = input('Motif ? ')

	"exe 'vimgrep! /' . l:motif . '/j' l:fichiers
	"cope 12

"endfu

" }}}

"  {{{ Helpgrep
" ------------------------------------------------------------------------

fu! bibliotheque#helpGrep(motif)

	exe 'tab helpgrep' a:motif
	cope 12

endfu

" }}}

"  {{{ RedirToBufferByRegister
" ------------------------------------------------------------------------

" fu! bibliotheque#redirToBufferByRegister(commande,...)

" 	if a:0 > 0
" 		let registre = a:1
" 	else
" 		let registre = 'a'
" 	endif

" 	exec 'redir @' . registre . '>'

" 	echo 'Commande :' a:commande
" 	echo 'Registre :' registre
" 	echo ''

" 	exec 'silent ' . a:commande

" 	redir END

" 	exec 'put ' . registre

" endfu

" }}}

"  {{{ RedirToTarget
" ------------------------------------------------------------------------

" fu! bibliotheque#redirToTarget(commande, cible)

" 	exec 'redir ' . a:cible

" 	echo 'Commande :' a:commande
" 	echo 'Cible de redirection :' a:cible
" 	echo ''

" 	exec 'silent ' . a:commande

" 	redir END

" endfu

" }}}

" {{{ TransposeBlocs, TransposePars

fun bibliotheque#transposeBlocs(...) range

	if a:0 > 0
		let Nblocs = a:1
	else
		call bibliotheque#transposePars()
		return 0
	endif

	let lignes = getline(a:firstline, a:lastline)

	call filter(lignes, 'v:val != ""')

	echo lignes

	let Nlignes = len(lignes)

	let lonBloc = Nlignes / Nblocs

	if Nlignes % Nblocs != 0
		let lonBloc += 1
	endif

	echo Nlignes Nblocs lonBloc

	let indice = 0
	let indligne = 0
	let depart = 0

	while indice < Nlignes

		echo indligne

		call setline(a:firstline + indice, lignes[indligne])

		let indice += 1

		let indligne += lonBloc

		if indligne >= Nlignes

			let depart += 1

			let indligne = depart

		endif

	endwhile

	let vide = a:firstline + Nlignes

	if vide <= a:lastline
		exe vide . ',' . a:lastline . 'delete'
	endif

endfun

fun bibliotheque#transposePars() range

endfun

" }}}

"  {{{ Génération de nombres aléatoires
" ------------------------------------------------------------------------

" Trouvé sur le web
" ------------------------------------

fu! bibliotheque#aleatoire(max)

   if exists('*Rndm')

		return Rndm() % a:max

	else

		redir => l:alea

			ruby << EOF

				rmax = VIM::evaluate("a:max")
				rmax = nil if rmax == ""
				printf rand(rmax).to_s

EOF

		redir END

		return strpart(l:alea, 1, strlen(l:alea) - 1)

	endif

endfu

" }}}

"  {{{ Date de modification
" ------------------------------------------------------------------------

fu! bibliotheque#dateModification()

	let ligne = line('.')
	let colonne = col('.')
	keepjumps normal gg

	if search('\c^[#"%] Last change:')

		"let dateHeure = strftime("%d-%m-%Y %H:%M:%S")
		let dateHeure = strftime("%A %d %B %Y, %H:%M")

		"exe 's/\c^" Last change:\s\+\zs..[-/]..[-/].. ..:..:../' . dateHeure . '/'
		"exe 's/\c^" Last change:\s\+\zs.*..:..:...*/' . dateHeure . '/'
		"exe 's/\c^" Last change:\s\+\zs.*\d\d:\d\d:\d\d.*/' . dateHeure . '/'
		"exe 's/\c^" Last change:\s\+\zs.*\d\d.*\d\{2,4}.*\d\d:\d\d:\d\d.*/' . dateHeure . '/'
		"exe 's/\c^" Last change:\s\+\zs.*\d\d.*\d\d\%(\d\d\)\?.*\d\d:\d\d:\d\d.*/' . dateHeure . '/'
		exe 's/\c^" Last change:\s\+\zs.*$/' . dateHeure . '/'
	endif

	keepjumps call cursor(ligne, colonne)
	norm zz
	"keepjumps exe "normal " . ligne . "G"
	"keepjumps exe "normal " . colonne . "|"

endfu

" }}}

"  {{{ Interrupteur background
" ------------------------------------------------------------------------

" function! bibliotheque#interrupteurBackground()

" 	if &background == "light"
" 		set background=dark
" 	else
" 		set background=light
" 	endif

" endfunction

" }}}

"  {{{ Fonction de complétion des fichiers dans le &path
" ------------------------------------------------------------------------

" Voir aussi :h :command puis recherche custom completion

fu! bibliotheque#editFileComplete(argument, cmdline, curseur)

	return split(globpath(&path, a:argument), "\n")

endfu

" }}}

"  {{{ Source répertoire
" ------------------------------------------------------------------------

" fu! bibliotheque#sourceRepertoire(repertoire)

" 	for l:fichier in split(glob(a:repertoire . '/**/*.vim'), '\n')

" 		exe 'source ' . l:fichier

" 	endfor

" endfu

" }}}

"  {{{ Shell
" ------------------------------------------------------------------------

" fu! bibliotheque#runShellCommand(cmdline)

" 	echo a:cmdline

" 	let expanded_cmdline = a:cmdline

" 	for part in split(a:cmdline, ' ')

" 		if part[0] =~ '\v[%#<]'
" 			let expanded_part = fnameescape(expand(part))
" 			let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
" 		endif

" 	endfor

" 	botright new

" 	setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap

" 	call setline(1, 'You entered:    ' . a:cmdline)
" 	call setline(2, 'Expanded Form:  ' .expanded_cmdline)
" 	call setline(3,substitute(getline(2),'.','=','g'))

" 	execute '$read !'. expanded_cmdline

" 	setlocal nomodifiable

" 	1

" endfu

" À placer dans maps.vim pour activer

" command! -complete=shellcmd -nargs=+ Shell call bibliotheque#runShellCommand(<q-args>)

" command! -complete=file -nargs=* Git call bibliotheque#runShellCommand('git '.<q-args>)
" command! -complete=file -nargs=* Svn call bibliotheque#runShellCommand('svn '.<q-args>)
" command! -complete=file -nargs=* Bzr call bibliotheque#runShellCommand('bzr '.<q-args>)
" command! -complete=file -nargs=* Hg  call bibliotheque#runShellCommand('hg '.<q-args>)

" }}}

"  {{{ Rendu HTML
" ------------------------------------------------------------------------

fu! bibliotheque#renduHtml()

	let l:motif = '<[/?]\?[^>]\+>'

	let l:ligne = getline('.')

	if l:ligne =~ l:motif
		let l:ligne = substitute(l:ligne, l:motif, '', 'g')
	endif

	let @/ = ligne

	let fichier = '.' . expand('%') . '.renduHtml'

	exe '!elinks -force-html -dump-width 84 -dump file://' . expand('%:p') '>|' fichier

	exe 'e' fichier

	norm gg

	if @/ != ''
		silent! norm n
	endif

endfu

" }}}

"  {{{ Navigation entre les tampons
" ------------------------------------------------------------------------

" Trouvé dans les vim tips
" Le but est de définir :
" nnoremap <silent> <C-n> :call bibliotheque#switchToNextBuffer(1)<CR>
" nnoremap <silent> <C-p> :call bibliotheque#switchToNextBuffer(-1)<CR>
" ------------------------------------

"fu! bibliotheque#switchToNextBuffer(incr)
	"let help_buffer = (&filetype == 'help')
	"let current = bufnr("%")
	"let last = bufnr("$")
	"let new = current + a:incr
	"while 1
		"if new != 0 && bufexists(new) && ((getbufvar(new, "&filetype") == 'help') == help_buffer)
			"execute ":buffer ".new
			"break
		"else
			"let new = new + a:incr
			"if new < 1
				"let new = last
			"elseif new > last
				"let new = 1
			"endif
			"if new == current
				"break
			"endif
		"endif
	"endwhile
"endfu

" }}}

"  {{{ Déplacement des onglets
" ------------------------------------------------------------------------

fu! bibliotheque#deplacementDesOnglets(delta)
	let N = tabpagenr() - 1 + a:delta
	echo N
	let N = max([N,0])
	exe "tabm" N
endfu

" }}}

"  {{{ Espace = nohlsearch / Ctrl-F
" ------------------------------------------------------------------------

" Ne fonctionne pas

" let s:recherche = ''
"
" fu! bibliotheque#nohlsearchOuCtrlF()
"
" 	if s:recherche != @/
"
" 		let s:recherche = @/
"
" 		nohlsearch
" 	else
" 		exe "norm! \<C-F>"
" 	endif
"
" endfu

" }}}

	let texte = substitute(texte, ' [0-9]$', '', '')				" }}}

	"let texte = substitute(texte, "[^[:alnum:][:space:]']*", '', 'g')
	"let texte = substitute(texte, '	\{2,}'', '	', 'g')
	"let texte = substitute(texte, '^\s\+', '', '')
	"let texte = substitute(texte, '\s\+$', '', '')

" ------------------------------------

" Exemples trouvés sur le net

" {{{ Recherche parmi les résultats de la liste quickfix

"	" Define a command to make it easier to use
"	command! -nargs=+ QFDo call QFDo(<q-args>)
"
"	" Function that does the work
"	function! QFDo(command)
"	    " Create a dictionary so that we can
"	    " get the list of buffers rather than the
"	    " list of lines in buffers (easy way
"	    " to get unique entries)
"	    let buffer_numbers = {}
"	    " For each entry, use the buffer number as
"	    " a dictionary key (won't get repeats)
"	    for fixlist_entry in getqflist()
"	        let buffer_numbers[fixlist_entry['bufnr']] = 1
"	    endfor
"	    " Make it into a list as it seems cleaner
"	    let buffer_number_list = keys(buffer_numbers)
"
"	    " For each buffer
"	    for num in buffer_number_list
"	        " Select the buffer
"	        exe 'buffer' num
"	        " Run the command that's passed as an argument
"	        exe a:command
"	        " Save if necessary
"	        update
"	    endfor
"	endfunction

" }}}

" {{{ Url --> Lien

fun! bibliotheque#url2link()

	g_^https\?://_s:^\(.*\)$:<a href="\1">\1</a><br />:

endfun

" }}}

" 	let chaine .= 'noautocmd'

" echomsg chemin_fichier
" echomsg fichier
" echomsg repertoire_fichier
" echomsg repertoire_sauvegarde
" echomsg sauvegarde

" {{{ Sauvegarde

fu! bibliotheque#sauvegarde(...)
	let sous_repertoire = ''
	let extension = ''
	if len(a:000) >= 1
		let sous_repertoire = a:1
	endif
	if len(a:000) >= 2
		let extension = a:2
	endif
	let chemin_fichier     = expand('%:p')
	let fichier            = expand('%:p:t')
	let repertoire_fichier = expand('%:p:h')
	let repertoire_sauvegarde = repertoire_fichier . '/.neovim/backup/' . sous_repertoire
	let sauvegarde = fichier . extension
	if ! filewritable(repertoire_fichier)
		echoerr 'bibliotheque#sauvegarde : ' . repertoire_fichier . ' protégé en écriture'
		return 1
	endif
	echomsg 'mkdir ' repertoire_sauvegarde
	if ! isdirectory(repertoire_sauvegarde)
		call mkdir(repertoire_sauvegarde, 'p')
	endif
	let chaine  = ''
	let chaine .= '! cp'
	let chaine .= ' '
	let chaine .= chemin_fichier
	let chaine .= ' '
	let chaine .= repertoire_sauvegarde
	let chaine .= '/'
	let chaine .= sauvegarde
	echomsg chaine
	"exe chaine
	call system(chaine)
endfu

" }}}

"  {{{ Taille d'un fichier

fu! bibliotheque#tailleFichier()
	let taille = getfsize(expand('%'))
	let gigas = floor(taille / s:GB)
	let taille -=  s:GB * gigas
	let megas = floor(taille / s:MB)
	let taille -=  s:MB * megas
	let kas = floor(taille / s:KB)
	let taille -=  s:KB * kas
	return string(megas) . ' G  ' . string(megas) . ' M  ' . string(kas) . ' K  ' . string(taille) . ' B'
endfu

" }}}

"  {{{ Taille d'un fichier

fu! bibliotheque#tailleFichier()
	let taille = getfsize(expand('%'))
	let gigas = floor(taille / s:GB)
	let taille -=  s:GB * gigas
	let megas = floor(taille / s:MB)
	let taille -=  s:MB * megas
	let kas = floor(taille / s:KB)
	let taille -=  s:KB * kas
	return string(megas) . ' G  ' . string(megas) . ' M  ' . string(kas) . ' K  ' . string(taille) . ' B'
endfu

" }}}

"  {{{ Codes couleurs

function! bibliotheque#codesCouleurs()
	silent! s:\v(.+)\s+(#)\s+(\w{2})\s+(\w{2})\s+(\w{2})\s+(\w+)\s+(\w+)\s+(\w+)(.*)$:\1			\2\3\4\5			rgb(\6, \7, \8)\9:
	silent! s:\v([^)])\)\s+(\w+)\s+(\w+)\s+(\w+)\s+(\w+)\s+(\w+)\s+(\w+)\s+(\w+):\1)			cmyk(\2, \3, \4, \5)			hsl(\6, \7%, \8%):
	silent! s: \ze[^(].*#::g
endfunction

com! -range CodesCouleurs <line1>,<line2>call bibliotheque#codesCouleurs()

" }}}

"  Redirection vers le tampon courant {{{1

fu! bibliotheque#redirToBuffer(commande)
	redir => contenu
	echo 'Commande :' a:commande
	echo ''
	exec 'silent ' . a:commande
	redir END
	new
	put =contenu
endfu

" }}}1

"  Recherche via grep {{{1

fu! bibliotheque#grep()
	let motif = input('Motif ? ')
	let fichiers = input('Fichiers ? ', expand('%:p:h') . '/*', 'file')
	if fichiers == ''
		let fichiers = expand('%:p:h') . '/**/*(.)'
	endif
	let chaine  = ''
	let chaine .= 'silent grep!'
	let chaine .= ' '
	let chaine .= "'"
	let chaine .= motif
	let chaine .= "'"
	let chaine .= ' '
	let chaine .= fichiers
	echomsg chaine
	exe chaine
	silent! cope 13
endfu

" }}}1

"  Recherche via vimgrep {{{1

fu! bibliotheque#vimgrep()
	let save_eventignore = &eventignore
	set eventignore=all
	let motif = input('Motif ? ')
	let fichiers = input('Fichiers ? ', expand('%:p:h') . '/*', 'file')
	if fichiers == ''
		let fichiers = expand('%:p:h') . '/**'
	endif
	let separateur = ''
	for candide in s:separateurs_de_motifs
		if ! (motif =~ candide)
			let separateur = candide
			break
		endif
	endfor
	if separateur == ''
		echoe 'Impossible de trouver un séparateur pour la substitution'
		return 1
	endif
	let chaine  = ''
	let chaine .= 'lvimgrep!'
	let chaine .= ' '
	let chaine .= separateur
	let chaine .= motif
	let chaine .= separateur
	let chaine .= 'j'
	let chaine .= ' '
	let chaine .= fichiers
	echomsg chaine
	exe chaine
	silent! lope 13
	let &eventignore = save_eventignore
endfu

" }}}1

"  Remplacement {{{1

fu! bibliotheque#remplacement()
	let save_eventignore = &eventignore
	set eventignore=all
	let motif = input('Motif ? ')
	let remplace = input('Remplacement ? ')
	let fichiers = input('Fichiers ? ', expand('%:p:h') . '/*', 'file')
	if fichiers == ''
		let fichiers = expand('%:p:h') . '/**/*(.)'
	endif
	let separateur = ''
	for candide in s:separateurs_de_motifs
		if ! (motif =~ candide)
			let separateur = candide
			break
		endif
	endfor
	if separateur == ''
		echoe 'Impossible de trouver un séparateur pour la substitution'
		return 1
	endif
	let chaine  = ''
	let chaine .= '! grep -l'
	let chaine .= ' '
	let chaine .= "'"
	let chaine .= motif
	let chaine .= "'"
	let chaine .= ' '
	let chaine .= fichiers
	echomsg chaine
	let contenu = system(chaine)
	let fichiers_filtres = substitute(contenu, '\n', ' ', 'g')
	arglocal
	let chaine  = ''
	let chaine .= 'args'
	let chaine .= ' '
	let chaine .= fichiers_filtres
	echomsg chaine
	exe chaine
	let chaine  = ''
	let chaine .= 'argdo'
	let chaine .= ' '
	let chaine .= '! cp % %.pre-sub'
	echomsg chaine
	exe chaine
	let chaine  = ''
	let chaine .= 'argdo'
	let chaine .= ' '
	let chaine .= 'silent %s'
	let chaine .= separateur
	let chaine .= motif
	let chaine .= separateur
	let chaine .= remplace
	let chaine .= separateur
	let chaine .= 'g'
	echomsg chaine
	exe chaine
	argglobal
	let &eventignore = save_eventignore
endfu

" }}}1

"  Remplacement via sed {{{1

fu! bibliotheque#remplacementSed()
	let motif = input('Motif ? ')
	let remplace = input('Remplacement ? ')
	let fichiers = input('Fichiers ? ', expand('%:p:h') . '/*', 'file')
	if fichiers == ''
		let fichiers = expand('%:p:h') . '/**/*(.)'
	endif
	let separateur = ''
	for candide in s:separateurs_de_motifs
		if ! (motif =~ candide)
			let separateur = candide
			break
		endif
	endfor
	if separateur == ''
		echoe 'Impossible de trouver un séparateur pour la substitution'
		return 1
	endif
	let chaine  = ''
	let chaine .= '! grep -l'
	let chaine .= ' '
	let chaine .= "'"
	let chaine .= motif
	let chaine .= "'"
	let chaine .= ' '
	let chaine .= fichiers
	echomsg chaine
	let contenu = system(chaine)
	let fichiers_filtres = substitute(contenu, '\n', ' ', 'g')
	let chaine  = ''
	let chaine .= '! sed --in-place=.pre-sed'
	let chaine .= ' '
	let chaine .= "'"
	let chaine .= 's'
	let chaine .= separateur
	let chaine .= motif
	let chaine .= separateur
	let chaine .= remplace
	let chaine .= separateur
	let chaine .= 'g'
	let chaine .= "'"
	let chaine .= ' '
	let chaine .= fichiers_filtres
	echomsg chaine
	"exe chaine
	call system(chaine)
endfu

" }}}1

fu! biblio#pliageParExpression()
	setlocal foldmethod=expr
	setlocal foldexpr=biblio#niveauDePliage(v:lnum)
endfu

fu! biblio#pliageParMarqueurs()
	setlocal foldmethod=marker
	setlocal foldmarker={{{,}}}
endfun

fu! biblio#niveauDePliage(noDeLigne)
	let ligne = getline(a:noDeLigne)
	for niveau in range(1,6)
		let expresso = '<h' . niveau . '.*>'
		if ligne =~? expresso
			return '>' . string(niveau)
		endif
	endfor
	let ligne = getline(a:noDeLigne + 1)
	for niveau in range(1,6)
		let expresso = '<h' . niveau . '.*>'
		if ligne =~? expresso
			return '<' . string(niveau)
		endif
	endfor
	return -1
endfu

let s:KB = 1024.0
let s:MB = s:KB * s:KB
let s:GB = s:KB * s:MB

let s:separateurs_de_motifs = [ '/', ':', '-', '_', ',', ';', '?', "'", '"' ]

	let relative_directory = fnamemodify(relative_filename, ':h')
	exe 'lcd ~/racine/public/' .. mode
	let returnstring = biblio#mkdir(relative_directory)
	let current_dir = getcwd()
	exe 'lcd' current_dir

	let filename = fnamemodify(expand('%'), ':p:r')
	let pdfname = filename .. '.pdf'

	\ '\m.*autostart*',
	\ '\m.*autostop*',

	nnoremap <buffer> l <Enter>
	exe "normal! \<c-w>T"
	tabonly
